(let ((cnt 0) (composition (make-array 2000 :adjustable t :fill-pointer 0)) (flag t))
  (defun compare (target m vec n)
	(dotimes (i n)
	  (let* ((patstr (svref vec i))
			 (len (length patstr))
			 (end (+ cnt len)))
		(if (> end m)
			nil
			(let ((substr (subseq target cnt end)))
			  (cond ((string= patstr substr)
					 (incf cnt len)
					 (vector-push patstr composition)
					 (return-from compare cnt))
					(t nil))))))
	(setf flag nil))
  
  (defun reset-closure ()
	(setf cnt 0)
	(setf composition (make-array 2000 :adjustable t :fill-pointer 0))
	(setf flag t))
  
  (defun judge (target m vec n)
	(do ()
		((>= cnt m) (progn (vec-print composition)
						   (reset-closure)))
	  (compare target m vec n)
	  (when (null flag)
		(format t "WRONG PASSWORD~%")
		(reset-closure)
		(return)))))

(defun vec-print (vec)
  (let ((len (length vec)))
	(dotimes (i len)
	  (format t "~A " (aref vec i)))
	(terpri)))

(defun group (n)
  (let ((vec (make-array 10)))
	(dotimes (i n)
	  (setf (svref vec i) (string-downcase (symbol-name (read)))))
	(let* ((target (read-line))
		   (m (length target)))
	  (judge target m vec n))))

(defun run ()
  (let ((groups (read)))
	(dotimes (i groups)
	  (let ((n (read)))
		(group n)))))

(run)
